---
layout: posttoc
title: "尝试测量Java对象的销毁时间"
subtitle: "抛砖引玉"
background: '/img/bg-.jpg'
published: false
imagefolder: ""
lastmodify: "2021-05-21"
tags: [Java]
---

>Oh, and one more thing: there is a severe performance penalty for using finalizers.
>
>On my machine, the time to create and destroy a simple object is about 5.6 ns. Adding a finalizer increases the time to 2,400 ns. 
>
>In other words, it is about 430 times slower to create and destroy objects with finalizers.
>
>------Effective Java Second Edition

很好奇大佬是如何测量时间的。创建一个简单对象还比较容易精确测量，销毁一个对象的时间就没那么容易精确测量了。因为JVM屏蔽了底层细节，程序员不知道它什么时候真正的销毁对象并回收资源。你可以提建议，但什么时候听就看我心情了。

思考了下，大概有这两条路：

* 从JVM入手，这应该是我所能想到的最精确的方法，比如在对象创建后或销毁后JVM有个Callback什么的。以上纯属YY:joy:，如有雷同，绝非巧合。时间、精力、脑力确实有限，没去近一步研究。
* 回到Java语言本身，不求精确的度量时间，只是粗略的测量然后比较一下，能表明有finalizer的对象创建和销毁**相对**比较耗时就行。比较差异的话，很多因素都可以忽略，比如GC的延迟时间，因为大家都一样，下面我们尝试走这一条路。

实验环境Win8.1：

{% highlight console %}
java version "1.8.0_45"
Java(TM) SE Runtime Environment (build 1.8.0_45-b15)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
{% endhighlight %}

#### V1

首先不能依赖`finalize()`方法来打卡时间点，没有这个方法的简单对象表示臣妾~做不到啊:sob:

最近刚好看到`java.lang.ref`包，`PhantomReference`代表最接近生命周期终点的*phantom reachable*，当GC认为referent，也就是我们的简单对象WithoutFinalization，变成*phantom reachable*的时候，它就会将该*reference*添加到*queue*中。

由于在Java语言里和GC的交互程度非常有限，那么我们就以这个时间点作为销毁对象的打卡时间点。

{% highlight java linenos %}
public class WithoutFinalization {

    public static void main(String[] args) {
        ReferenceQueue<WithoutFinalization> queue = new ReferenceQueue<>();
        long start = System.nanoTime();
        
        PhantomReference<WithoutFinalization> rf = new PhantomReference<>(
                                                new WithoutFinalization(), queue);
        System.gc();//advise JVM to do GC
        
        Object x = null;
        int i = 0;
        do{
            x = queue.poll();
            i++;
        }while(x == null);
        //only need this time point
        System.out.println(i +" "+(System.nanoTime() - start));
    }
}
{% endhighlight %}

这个版本算是毛坯，创建和销毁的时间合在一起测量，结果确实也很粗糙，运行了几次，最好记录是：`5287090 ns`:sweat:

这个确实差太远了，这还是没有`finalize()`方法的简单对象。

在这一版本中，如果`finalize()`方法体有哪怕一条语句，GC就像不回收一样，*reference*一直不enqueue，程序就卡在`do-while`循环。在最后的版本中才发现问题所在，现在我们先跳过这个问题。

下面继续改进下。

#### V2

为了更精确一点，我们分开测量创建和销毁时间。//TODO 测量起点需要改下先sleep后gc，必须先gc后sleep？

{% highlight java linenos %}

public class WithoutFinalizationV2 {
    
    public static void main(String[] args) throws Exception {
        
        long createTime = System.nanoTime();
        WithoutFinalizationV2 o = new WithoutFinalizationV2();
        createTime = System.nanoTime() - createTime;
        
        ReferenceQueue<WithoutFinalizationV2> queue = new ReferenceQueue<>();
        PhantomReference<WithoutFinalizationV2> rf = new PhantomReference<>(o, queue);
        o = null;//explicitly clear reference
        System.gc();//advise JVM to do GC
        
        Object x = null;
        int waitCount = 0;
        long destroyTime = System.nanoTime();
        do{
            x = queue.poll();
            waitCount++;
        }while(x == null);
        //only need this time point
        destroyTime = System.nanoTime() - destroyTime;
        System.out.println(waitCount +" "+createTime +" "+ destroyTime);
    }
}

{% endhighlight %}

这次的结果相对好太多：`3421+11547=14968 ns`

#### V3

在程序上已经做到尽量贴近测量了，要想进一步提高成绩，只有利用JVM的HotSpot来优化性能。在官方文档只找到了方法调用次数的阈值，Server VM是一万次调用。网上搜了下，OSR也差不多是这个次数。

这个版本采用先构造一堆对象然后挨个销毁最后计算平均时间。

在测试中遇到个问题，当运行次数接近五六百次的时候，*reference*又不enqueue了。推测是GC调用太频繁，罢工了，sleep一下就好了，休息的时间长短不影响测量结果，只影响程序整个运行时间。

然后又尝试运行在`-Xcomp`模式，不幸的是程序会卡在销毁对象的地方，具体原因就不知道了，可能优化太激进了吧。

注释掉销毁对象的部分，运行在`-Xcomp`模式，仅仅创建一个对象的最低时间是`21 ns`

Mac createTime=119 destroyTime=5415 / createTime=160 destroyTime=5058

{% highlight java linenos %}

public class WithoutFinalizationV3 {

    public static void main(String[] args) throws Exception {
        int times = 30*1000;
        long createTime = 0;
        long destroyTime= 0;
        
        WithoutFinalizationV3[] oarray = new WithoutFinalizationV3[times];
        for(int i=0; i<times; i++){//On-Stack Replacement
            long createStart = System.nanoTime();
            WithoutFinalizationV3 o = new WithoutFinalizationV3();
            createTime += System.nanoTime() - createStart;
            oarray[i] = o;
        }
        
        for(int i=0; i<times; i++){//On-Stack Replacement
            ReferenceQueue<WithoutFinalizationV3> queue = new ReferenceQueue<>();
            PhantomReference<WithoutFinalizationV3> rf = new PhantomReference<>(oarray[i], queue);
            oarray[i] = null;//explicitly clear reference
            System.gc();//advise JVM to do GC
            Thread.sleep(0, 100);//avoid GC strikes
            
            Object x = null;
            long destroyStart = System.nanoTime();
            do{
                x = queue.poll();
            }while(x == null);
            //only need this time point
            destroyTime += System.nanoTime() - destroyStart;
        }
        
        System.out.println("createTime="+createTime/times);
        System.out.println("destroyTime="+destroyTime/times);
    }
}

{% endhighlight %}



#### V4

这个版本改变成构造一个销毁一个的方式。

{% highlight java linenos %}

public class WithoutFinalizationV4 {

    public static void main(String[] args) throws Exception {
        //10 no array 1624 16849
        //2k 1959 7974, no array 1490 8115
        //20K 2388 7467
        //30k 667 1905
        int times = 30*1000;
        
        long createTime = 0;
        long destroyTime = 0;
        
        for(int i=0; i<times; i++){//On-Stack Replacement
            long createStart = System.nanoTime();
            WithoutFinalizationV4 o = new WithoutFinalizationV4();
            createTime += System.nanoTime() - createStart;
            
            ReferenceQueue<WithoutFinalizationV4> queue = new ReferenceQueue<>();
            PhantomReference<WithoutFinalizationV4> rf = new PhantomReference<>(o, queue);
            o = null;//explicitly clear reference
            System.gc();//advise JVM to do GC
            Thread.sleep(0, 100);//avoid GC strikes
            
            Object x = null;
            long destroyStart = System.nanoTime();
            do{
                x = queue.poll();
            }while(x == null);
            //only need this time point
            destroyTime += System.nanoTime() - destroyStart;
            System.out.println(i + " Done");
        }
        
        System.out.println("createTime="+createTime/times);
        System.out.println("destroyTime="+destroyTime/times);
    }
}

{% endhighlight %}

finalize需要GC两次。

*[JVM]:Java Virtual Machine
*[GC]:Garbage Collection

*[OSR]:On-Stack Replacement